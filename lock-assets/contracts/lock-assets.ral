Contract LockAssets() {
    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn lockAlphOnly(amount: U256) -> () {
        emit Debug(`lockAlphOnly`)
        let caller = callerAddress!()
        lockApprovedAssets!{caller -> ALPH: amount}(caller, blockTimeStamp!() + 86400000) // 1 day
    }

    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn lockTokenOnly(tokenId: ByteVec, amount: U256) -> () {
        emit Debug(`lockTokenOnly`)
        let caller = callerAddress!()
        lockApprovedAssets!{caller -> ALPH: dustAmount!(), tokenId: amount}(caller, blockTimeStamp!() + 86400000) // 1 day
    }

    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn lockAlphAndToken(alphAmount: U256, tokenId: ByteVec, tokenAmount: U256) -> () {
        emit Debug(`lockAlphAndToken`)
        let caller = callerAddress!()
        lockApprovedAssets!{caller -> ALPH: alphAmount, tokenId: tokenAmount}(caller, blockTimeStamp!() + 86400000) // 1 day
    }

    @using(checkExternalCaller = false)
    pub fn mintAndLockToken(
        tokenContractTemplateId: ByteVec,
        tokenName: ByteVec,
        recipient: Address,
        amount: U256,
        till: U256
    ) -> () {
        emit Debug(`mintAndLockToken`)
        let tokenContractId = copyCreateSubContractWithToken!(
            tokenName, tokenContractTemplateId, #00, #00, amount
        )
        TokenToBeLocked(tokenContractId).lockTokens(recipient, amount, till)
    }
}

Contract TokenToBeLocked() {
    @using(assetsInContract = true, checkExternalCaller = false)
    pub fn lockTokens(recipient: Address, amount: U256, till: U256) -> () {
      lockApprovedAssets!{selfAddress!() -> selfTokenId!(): amount, ALPH: dustAmount!()}(recipient, till)
    }
}
