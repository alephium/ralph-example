Contract Staking(
    tokenId: ByteVec,
    rewardsTokenId: ByteVec,
    stakingAccountTemplateId: ByteVec,
    mut rewardRate: U256,
    mut totalAmountStaked: U256,
    mut rewardPerTokenStored: U256,
    mut lastUpdateTime: U256,
    mut startTime: U256,
    mut duration: U256,
    mut earlyUnstakePenaltyPercent: U256,
    mut owner_: Address,
    mut poolPerformanceMultiplier: U256
) extends StakingAccountFactory(tokenId, rewardsTokenId, stakingAccountTemplateId), StakingTimeBond(startTime, duration, earlyUnstakePenaltyPercent, owner_) {
    ////////////////////////
    // Events
    ////////////////////////

    event Staked(staker: Address, amount: U256)
    event Unstaked(staker: Address, amount: U256)
    event ClaimedRewards(staker: Address, amount: U256)
    event RewardRateUpdated(rewardRate: U256)
    event PoolPerformanceUpdated(oldMultiplier: U256, newMultiplier: U256)
    event RewardsCompounded(staker: Address, amount: U256)

    ////////////////////////
    // Error Codes
    ////////////////////////

    enum ErrorCodes {
        PoolNotStarted = 0,
        NoRewardsToCompound = 1,
        ConversionFailed = 2
    }

    ////////////////////////
    // Internal Functions
    ////////////////////////
    fn earned(account: StakingAccount) -> U256 {
        let staked = account.getAmountStaked()
        let rewardPerTokenPaid = account.getRewardPerTokenPaid()
        let currentRewardPerToken = calculateRewardPerToken()
        let oldRewards = account.getRewards()
        let stakeDuration = blockTimeStamp!() - account.getStakingStartTime()

        let durationMultiplier = if (stakeDuration > 30 days) {
            1e18 + 1e17 // 1.1x for 30+ days
        } else if (stakeDuration > 7 days) {
            1e18 + 5e16 // 1.05x for 7+ days
        } else {
            1e18
        }

        let baseEarnedRewards = ((staked * (currentRewardPerToken - rewardPerTokenPaid)) / 1e18) + oldRewards
        
        return (baseEarnedRewards * poolPerformanceMultiplier * durationMultiplier) / (1e18 * 1e18)
    }

    fn updateStakerReward(account: StakingAccount) -> () {
        updateReward()
        let reward = earned(account)

        account.setRewards(reward, rewardPerTokenStored)
    }

    @using(updateFields = true)
    fn updateReward() -> () {
        rewardPerTokenStored = calculateRewardPerToken()
        lastUpdateTime = blockTimeStamp!()
    }

    fn calculateRewardPerToken() -> U256 {
        if (totalAmountStaked == 0) {
            return rewardPerTokenStored
        }

        let baseReward = ((blockTimeStamp!() - lastUpdateTime) * rewardRate * 1e18) / totalAmountStaked
        return rewardPerTokenStored + baseReward
    }

    @using(assetsInContract = true)
    fn sendRewards(account: StakingAccount) -> U256 {
        let self = selfAddress!()
        let stakingRewards = account.getRewards()

        let amount = account.claimRewards{self -> rewardsTokenId: stakingRewards}()

        return amount
    }

    ////////////////////////
    // Public Functions
    ////////////////////////

    pub fn getTokenId() -> ByteVec {
        return tokenId
    }

    pub fn getRewardsTokenId() -> ByteVec {
        return rewardsTokenId
    }

    @using(preapprovedAssets = true, updateFields = true, checkExternalCaller = false)
    pub fn stake(amount: U256) -> () {
        assert!(isPoolStarted(), ErrorCodes.PoolNotStarted)
        let staker = callerAddress!()

        if (stakingAccountExists(staker)) {
            let stakingAccount = getStakingAccount(staker)
            updateStakerReward(stakingAccount)

            stakingAccount.stake{staker -> tokenId: amount}(amount)
        } else {
            updateReward()
            createStakingAccount{staker -> ALPH: 1 alph, tokenId: amount}(staker, amount, rewardPerTokenStored)
        }
        
        totalAmountStaked = totalAmountStaked + amount
        emit Staked(staker, amount)
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn unstake(amount: U256) -> () {
        let staker = callerAddress!()

        let stakingAccount = getStakingAccount(staker)

        updateStakerReward(stakingAccount)
        let rewardAmount = sendRewards(stakingAccount)
        emit ClaimedRewards(staker, rewardAmount)

        if (isPoolEnded()) {
            stakingAccount.unstake(amount)
        } else {
            stakingAccount.unstakeWithPenalty(amount, earlyUnstakePenaltyPercent)
        }

        totalAmountStaked = totalAmountStaked - amount

        emit Unstaked(staker, amount)
    }

    @using(checkExternalCaller = false)
    pub fn claimRewards() -> () {
        let staker = callerAddress!()

        let stakingAccount = getStakingAccount(staker)

        updateStakerReward(stakingAccount)
        let amount = sendRewards(stakingAccount)

        emit ClaimedRewards(staker, amount)
    }

    @using(updateFields = true, checkExternalCaller = false)
    pub fn compoundRewards() -> () {
        let staker = callerAddress!()
        let stakingAccount = getStakingAccount(staker)
        
        // Calculate and update rewards
        updateStakerReward(stakingAccount)
        let rewardsToCompound = stakingAccount.getRewards()
        assert!(rewardsToCompound > 0, ErrorCodes.NoRewardsToCompound)
        
        // Convert rewards to staking tokens (through reward token)
        stakingAccount.convertAndStakeRewards{selfAddress!() -> rewardsTokenId: rewardsToCompound}()
        
        emit RewardsCompounded(staker, rewardsToCompound)
    }

    ////////////////////////
    // Admin Functions
    ////////////////////////
    
    @using(updateFields = true)
    pub fn setRewardRate(rate: U256) -> () {
        onlyOwner(callerAddress!())

        rewardRate = rate

        emit RewardRateUpdated(rate)
    }

    pub fn upgrade(newBytecode: ByteVec) -> () {
        onlyOwner(callerAddress!())

        migrate!(newBytecode)
    }

    @using(updateFields = true)
    pub fn updatePoolPerformance(newMultiplier: U256) -> () {
        onlyOwner(callerAddress!())
        assert!(newMultiplier > 0, ErrorCodes.InvalidMultiplier)
        
        let oldMultiplier = poolPerformanceMultiplier
        poolPerformanceMultiplier = newMultiplier
        emit PoolPerformanceUpdated(oldMultiplier, newMultiplier)
    }
}
