Contract RewardSystem(
    tokenId: ByteVec,
    rewardTokenId: ByteVec,
    mut baseRewardRate: U256,
    mut poolPerformanceMultiplier: U256,
    owner: Address
) {
    const Day = 86400
    const PRECISION = 1_000_000_000_000_000_000 // 1e18

    event RewardsClaimed(staker: Address, amount: U256)
    event RewardsCompounded(staker: Address, amount: U256)
    event PoolPerformanceUpdated(oldMultiplier: U256, newMultiplier: U256)

    enum ErrorCodes {
        NoRewardsToClaim = 0
        InvalidMultiplier = 1
        NotOwner = 2
        InvalidAmount = 3
    }

    struct StakerInfo {
        mut stakedAmount: U256
        mut stakingStartTime: U256
        mut lastUpdateTime: U256
        mut pendingRewards: U256
    }

    mapping(Address => StakerInfo) mut stakerInfos

    fn checkCaller(caller: Address) -> () {
        assert!(caller == owner, ErrorCodes.NotOwner)
    }

    fn getTimeMultiplier(stakingDuration: U256) -> U256 {
        if (stakingDuration >= 30 * Day) {
            return PRECISION + PRECISION / 10 // 1.1x
        } else if (stakingDuration >= 7 * Day) {
            return PRECISION + PRECISION / 20 // 1.05x
        }
        return PRECISION
    }

    fn calculateReward(staker: Address) -> U256 {
        let info = stakerInfos[staker]
        let duration = blockTimeStamp!() - info.lastUpdateTime
        let timeMultiplier = getTimeMultiplier(blockTimeStamp!() - info.stakingStartTime)
        
        let baseReward = (info.stakedAmount * duration * baseRewardRate) / PRECISION
        let poolAdjusted = (baseReward * poolPerformanceMultiplier) / PRECISION
        return (poolAdjusted * timeMultiplier) / PRECISION
    }

    @using(updateFields = true)
    pub fn stake(amount: U256) -> () {
        assert!(amount > 0, ErrorCodes.InvalidAmount)
        let staker = callerAddress!()
        let mut info = stakerInfos[staker]
        
        if (info.stakedAmount == 0) {
            info.stakingStartTime = blockTimeStamp!()
        } else {
            let pendingReward = calculateReward(staker)
            info.pendingRewards = info.pendingRewards + pendingReward
        }
        
        transferToken!(staker, selfAddress!(), tokenId, amount)
        info.stakedAmount = info.stakedAmount + amount
        info.lastUpdateTime = blockTimeStamp!()
        stakerInfos[staker] = info
    }

    @using(updateFields = true)
    pub fn withdraw(amount: U256) -> () {
        assert!(amount > 0, ErrorCodes.InvalidAmount)
        let staker = callerAddress!()
        let mut info = stakerInfos[staker]
        assert!(info.stakedAmount >= amount, ErrorCodes.InvalidAmount)
        
        let pendingReward = calculateReward(staker)
        info.pendingRewards = info.pendingRewards + pendingReward
        
        transferToken!(selfAddress!(), staker, tokenId, amount)
        info.stakedAmount = info.stakedAmount - amount
        info.lastUpdateTime = blockTimeStamp!()
        stakerInfos[staker] = info
    }

    @using(updateFields = true)
    pub fn claimRewards() -> () {
        let staker = callerAddress!()
        let mut info = stakerInfos[staker]
        
        let currentReward = calculateReward(staker)
        let totalRewards = info.pendingRewards + currentReward
        assert!(totalRewards > 0, ErrorCodes.NoRewardsToClaim)
        
        transferToken!(selfAddress!(), staker, rewardTokenId, totalRewards)
        info.pendingRewards = 0
        info.lastUpdateTime = blockTimeStamp!()
        stakerInfos[staker] = info
        
        emit RewardsClaimed(staker, totalRewards)
    }

    @using(updateFields = true)
    pub fn compoundRewards() -> () {
        let staker = callerAddress!()
        let mut info = stakerInfos[staker]
        
        let currentReward = calculateReward(staker)
        let totalRewards = info.pendingRewards + currentReward
        assert!(totalRewards > 0, ErrorCodes.NoRewardsToClaim)
        
        info.stakedAmount = info.stakedAmount + totalRewards
        info.pendingRewards = 0
        info.lastUpdateTime = blockTimeStamp!()
        stakerInfos[staker] = info
        
        emit RewardsCompounded(staker, totalRewards)
    }

    @using(updateFields = true)
    pub fn updatePoolPerformance(newMultiplier: U256) -> () {
        checkCaller(callerAddress!())
        assert!(newMultiplier > 0, ErrorCodes.InvalidMultiplier)
        
        let oldMultiplier = poolPerformanceMultiplier
        poolPerformanceMultiplier = newMultiplier
        emit PoolPerformanceUpdated(oldMultiplier, newMultiplier)
    }

    pub fn getStakerInfo(staker: Address) -> StakerInfo {
        return stakerInfos[staker]
    }
} 